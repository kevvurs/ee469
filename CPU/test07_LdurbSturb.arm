// Test of LDURB and STURB instructions
// Requires:
// B, ADDI, LDURB, STURB, LDUR, & STUR instructions
// Expected results:
// X0 = 0xABC
// X1 = 0xDEADBEEFDECAFBAD
// X8 = 0xBC
// X9 = 0x0A
// X10..X15 = 0
// Mem[7:0] = 0xDEADBEEFDECAFBAD
// Mem[15:7] = 0xABC

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//LDURB: D-type, Reg[Rt] = {52'b0, Mem[Reg[Rn] + SignExtend(Imm9)][7:0]}
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//00111000010 2's Comp  00 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

//STURB: D-type, Mem[Reg[Rn] + SignExtend(Imm9)][7:0] = Reg[Rt][7:0]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//00111000000 2's Comp  00 0..31 0..31

               // MAIN:
1001000100_000011011110_11111_00000	// ADDI X0, X31, #222	// X0 = 0xDE
00111000000_000000111_00_11111_00000	// STURB X0, [X31, #7]
00111000000_000000011_00_11111_00000	// STURB X0, [X31, #3]
1001000100_000010101101_11111_00000	// ADDI X0, X31, #173	// X0 = 0xAD
00111000000_000000110_00_11111_00000	// STURB X0, [X31, #6]
00111000000_000000000_00_11111_00000	// STURB X0, [X31, #0]
1001000100_000010111110_11111_00000	// ADDI X0, X31, #190	// X0 = 0xBE
00111000000_000000101_00_11111_00000	// STURB X0, [X31, #5]
1001000100_000011101111_11111_00000	// ADDI X0, X31, #239	// X0 = 0xEF
00111000000_000000100_00_11111_00000	// STURB X0, [X31, #4]
1001000100_000011001010_11111_00000	// ADDI X0, X31, #202	// X0 = 0xCA
00111000000_000000010_00_11111_00000	// STURB X0, [X31, #2]
1001000100_000011111011_11111_00000	// ADDI X0, X31, #251	// X0 = 0xFB
00111000000_000000001_00_11111_00000	// STURB X0, [X31, #1]
11111000010_000000000_00_11111_00001	// LDUR X1, [X31, #0]	// Read back the full 64 bits
1001000100_101010111100_11111_00000	// ADDI X0, X31, #2748	// X0 = 0xABC
11111000000_000001000_00_11111_00000	// STUR X0, [X31, #8]	// Write 0xABC to [15:7], so we can read it back.
00111000010_000001000_00_11111_01000	// LDURB X8, [X31, #8]
00111000010_000001001_00_11111_01001	// LDURB X9, [X31, #9]
00111000010_000001010_00_11111_01010	// LDURB X10, [X31, #10]
00111000010_000001011_00_11111_01011	// LDURB X11, [X31, #11]
00111000010_000001100_00_11111_01100	// LDURB X12, [X31, #12]
00111000010_000001101_00_11111_01101	// LDURB X13, [X31, #13]
00111000010_000001110_00_11111_01110	// LDURB X14, [X31, #14]
00111000010_000001111_00_11111_01111	// LDURB X15, [X31, #15]
000101_00000000000000000000000000	// HALT:B HALT          // HALT = 0
1001000100_000000000000_11111_11111	// ADDI X31, X31, #0    // Bogus instruction – pipelined CPU may need it
